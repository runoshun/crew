package domain

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// Note: embed is no longer used - config_template.toml was removed
// Template is now dynamically generated by RenderConfigTemplate(cfg)

// Config represents the application configuration.
type Config struct {
	Agents         map[string]Agent   // Agent definitions from [agents.<name>]
	WorkersConfig  WorkersConfig      // Common [workers] settings
	Workers        map[string]Worker  // Per-worker settings [workers.<name>]
	ManagersConfig ManagersConfig     // Common [managers] settings
	Managers       map[string]Manager // Manager definitions from [managers.<name>]
	Complete       CompleteConfig     // [complete] settings
	Diff           DiffConfig         // [diff] settings
	Log            LogConfig          // [log] settings
	Tasks          TasksConfig        // [tasks] settings
	Worktree       WorktreeConfig     // [worktree] settings
	Warnings       []string           // [warning] Unknown keys or other issues
}

// TasksConfig holds settings for task storage from [tasks] section.
type TasksConfig struct {
	Store     string // Storage backend: "git" (default) or "json"
	Namespace string // Git namespace for refs (default: "crew")
	Encrypt   bool   // Enable encryption for task data (default: false)
}

// WorkersConfig holds common settings for all workers from [workers] section.
type WorkersConfig struct {
	SystemPrompt string // Default system prompt for all workers
	Prompt       string // Default prompt for all workers (can be overridden per worker)
}

// ManagersConfig holds common settings for all managers from [managers] section.
type ManagersConfig struct {
	SystemPrompt string // Default system prompt for all managers
	Prompt       string // Default prompt for all managers (can be overridden per manager)
}

// Agent defines a base agent configuration that Workers and Managers can reference.
// Agents define the core command execution pattern without being tied to a specific role.
// Note: SystemArgs is NOT defined here; it's a role-specific (Worker/Manager) concern.
type Agent struct {
	Command             string
	CommandTemplate     string
	DefaultModel        string
	Description         string
	WorktreeSetupScript string
	ExcludePatterns     []string
}

// Worker holds per-worker configuration from [workers.<name>] sections.
// Workers are task execution agents that can reference an Agent for base settings.
type Worker struct {
	Agent           string // Name of the Agent to inherit from (optional)
	Inherit         string // Name of worker to inherit from (optional, for worker-to-worker inheritance)
	CommandTemplate string // Template for assembling the command (e.g., "{{.Command}} {{.SystemArgs}} {{.Args}} {{.Prompt}}")
	Command         string // Base command (e.g., "claude", "opencode")
	SystemArgs      string // System arguments required for crew operation (auto-applied)
	Args            string // User-customizable arguments (e.g., model selection)
	Model           string // Default model for this worker (overrides builtin default)
	SystemPrompt    string // System prompt template for this worker
	Prompt          string // Prompt template for this worker
	Description     string // Description of the worker's purpose
}

// Manager holds configuration for manager agents from [managers.<name>] sections.
// Managers are read-only orchestration agents that can create and monitor tasks.
type Manager struct {
	Agent        string // Name of the Agent to inherit from (optional)
	Model        string // Model override for this manager
	SystemArgs   string // System arguments required for crew operation (auto-applied)
	Args         string // Additional arguments for this manager
	SystemPrompt string // System prompt template for this manager
	Prompt       string // Prompt template for this manager
	Description  string // Description of the manager's purpose
}

// CommandData holds data for rendering agent commands and prompts.
// Fields are ordered to minimize memory padding.
type CommandData struct {
	// Environment
	GitDir   string // Path to .git directory
	RepoRoot string // Repository root path
	Worktree string // Worktree path (if using worktrees)

	// Task information
	Title       string
	Description string
	Branch      string // Branch name (e.g., "crew-1")

	// Runtime options
	Model string // Model name override (e.g., "sonnet", "gpt-4o")

	// Integer fields grouped together for alignment
	Issue  int // GitHub issue number (0 if not linked)
	TaskID int

	// Boolean fields
	Continue bool // --continue flag was specified
}

// RenderCommandResult holds the results of RenderCommand.
type RenderCommandResult struct {
	Command string // The full command to execute (e.g., `claude --model opus "$PROMPT"`)
	Prompt  string // The prompt content to be stored in PROMPT shell variable
}

// RenderCommand renders the full command string and prompt content for this worker.
// It performs three-phase template expansion:
// 1. Expand SystemArgs and Args with CommandData (for GitDir, RepoRoot, TaskID, etc.)
// 2. Expand SystemPrompt and Prompt templates with CommandData to generate prompt content
// 3. Expand CommandTemplate with Command, expanded SystemArgs/Args, and shell variable reference
//
// The promptOverride parameter is the shell variable reference (e.g., `"$PROMPT"`) that will be
// embedded in the command and expanded at runtime to the actual prompt content.
// The defaultSystemPrompt is used when Worker.SystemPrompt is empty.
// The defaultPrompt is used when Worker.Prompt is empty.
func (w *Worker) RenderCommand(data CommandData, promptOverride, defaultSystemPrompt, defaultPrompt string) (RenderCommandResult, error) {
	// Phase 1: Expand SystemArgs and Args
	systemArgs, err := expandString(w.SystemArgs, data)
	if err != nil {
		return RenderCommandResult{}, err
	}
	args, err := expandString(w.Args, data)
	if err != nil {
		return RenderCommandResult{}, err
	}

	// Phase 2: Expand Prompt templates to generate prompt content
	sysPromptTemplate := w.SystemPrompt
	if sysPromptTemplate == "" {
		sysPromptTemplate = defaultSystemPrompt
	}
	sysPromptContent, err := expandString(sysPromptTemplate, data)
	if err != nil {
		return RenderCommandResult{}, err
	}

	userPromptTemplate := w.Prompt
	if userPromptTemplate == "" {
		userPromptTemplate = defaultPrompt
	}
	userPromptContent, err := expandString(userPromptTemplate, data)
	if err != nil {
		return RenderCommandResult{}, err
	}

	// Combine SystemPrompt and Prompt
	var promptContent string
	if sysPromptContent != "" && userPromptContent != "" {
		promptContent = sysPromptContent + "\n\n" + userPromptContent
	} else if sysPromptContent != "" {
		promptContent = sysPromptContent
	} else {
		promptContent = userPromptContent
	}

	// Phase 3: Expand CommandTemplate
	cmdData := map[string]any{
		"Command":    w.Command,
		"SystemArgs": systemArgs,
		"Args":       args,
		"Prompt":     promptOverride,
		"Continue":   data.Continue,
	}

	tmpl, err := template.New("cmd").Parse(w.CommandTemplate)
	if err != nil {
		return RenderCommandResult{}, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cmdData); err != nil {
		return RenderCommandResult{}, err
	}

	return RenderCommandResult{
		Command: buf.String(),
		Prompt:  promptContent,
	}, nil
}

// expandString expands template variables in a string.
func expandString(s string, data CommandData) (string, error) {
	if s == "" {
		return "", nil
	}

	tmpl, err := template.New("expand").Parse(s)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// CompleteConfig holds completion gate settings from [complete] section.
type CompleteConfig struct {
	Command string // Command to run as CI gate on complete
}

// DiffConfig holds diff display settings from [diff] section.
type DiffConfig struct {
	Command    string // Command to display diff (with {{.Args}} template support)
	TUICommand string // Command for TUI diff display
}

// LogConfig holds logging settings from [log] section.
type LogConfig struct {
	Level string // Log level: debug, info, warn, error
}

// WorktreeConfig holds worktree customization settings from [worktree] section.
type WorktreeConfig struct {
	SetupCommand string   // Command to run after worktree creation
	Copy         []string // Files/directories to copy (with CoW if available)
}

// Default configuration values.
const (
	DefaultLogLevel    = "info"
	DefaultWorkerName  = "default" // Name of the default worker (looked up in Workers map)
	DefaultManagerName = "default" // Name of the default manager (looked up in Managers map)
)

// DefaultSystemPrompt is the default system prompt template for workers.
// It uses Go template syntax with CommandData fields.
const DefaultSystemPrompt = `You are working on Task #{{.TaskID}}.

IMPORTANT: First run 'crew --help-worker' and follow the workflow instructions exactly.`

// DefaultManagerSystemPrompt is the default system prompt template for managers.
const DefaultManagerSystemPrompt = `You are a Manager agent for git-crew.

IMPORTANT: Run 'crew --help-manager' for detailed usage instructions.

Your role is to:
- Support users with task management
- Create, monitor, and manage tasks using crew commands
- Delegate code implementation to worker agents (do not edit files directly)`

// Directory and file names for git-crew.
const (
	CrewDirName    = "crew"        // Directory name for crew data
	ConfigFileName = "config.toml" // Config file name
)

// RepoCrewDir returns the crew directory path for a repository.
func RepoCrewDir(repoRoot string) string {
	return filepath.Join(repoRoot, ".git", CrewDirName)
}

// RepoConfigPath returns the repo config path.
func RepoConfigPath(repoRoot string) string {
	return filepath.Join(RepoCrewDir(repoRoot), ConfigFileName)
}

// GlobalCrewDir returns the global crew directory path.
// configHome is typically XDG_CONFIG_HOME or ~/.config (resolved by caller).
func GlobalCrewDir(configHome string) string {
	return filepath.Join(configHome, CrewDirName)
}

// GlobalConfigPath returns the global config path.
// configHome is typically XDG_CONFIG_HOME or ~/.config (resolved by caller).
func GlobalConfigPath(configHome string) string {
	return filepath.Join(GlobalCrewDir(configHome), ConfigFileName)
}

// NewDefaultConfig returns a Config with default values.
// This returns empty maps for Agents, Workers, and Managers.
// Builtin agents should be registered by calling builtin.Register(cfg)
// in the infra layer before merging user config.
func NewDefaultConfig() *Config {
	return &Config{
		Agents: make(map[string]Agent),
		WorkersConfig: WorkersConfig{
			SystemPrompt: DefaultSystemPrompt,
			Prompt:       "",
		},
		Workers: make(map[string]Worker),
		ManagersConfig: ManagersConfig{
			SystemPrompt: DefaultManagerSystemPrompt,
			Prompt:       "",
		},
		Managers: make(map[string]Manager),
		Log: LogConfig{
			Level: DefaultLogLevel,
		},
	}
}

// RenderConfigTemplate renders a config template dynamically from the given Config.
// The generated template includes all registered workers, managers, and agents as
// commented examples that users can uncomment and customize.
func RenderConfigTemplate(cfg *Config) string {
	var buf strings.Builder

	// Header
	buf.WriteString("# git-crew configuration\n\n")

	// Workers section
	buf.WriteString("[workers]\n")
	buf.WriteString("## Workers are task execution agents that reference an Agent or define their own command.\n")
	buf.WriteString(fmt.Sprintf("# default = %q  # Default worker to use when starting tasks\n", DefaultWorkerName))
	buf.WriteString(fmt.Sprintf("# system_prompt = %s # System prompt (automatically set by crew)\n", formatPromptForTemplate(cfg.WorkersConfig.SystemPrompt)))
	buf.WriteString(fmt.Sprintf("# prompt = %s               # User custom instructions (added after system_prompt)\n", formatPromptForTemplate(cfg.WorkersConfig.Prompt)))
	buf.WriteString("\n")
	buf.WriteString("## Built-in worker customization\n")
	buf.WriteString("## - agent: Name of the agent to use (builtin: claude, opencode)\n")
	buf.WriteString("## - model: Model name override (takes precedence over agent's default_model)\n")
	buf.WriteString("## - system_args: System arguments for crew operation (rarely need to change)\n")
	buf.WriteString("## - args: User-customizable arguments\n")
	buf.WriteString("## - system_prompt: Override the common system prompt for this worker\n")
	buf.WriteString("## - prompt: Override the common prompt for this worker\n")
	buf.WriteString("\n")

	// Generate worker examples from registered workers (sorted for deterministic output)
	workerNames := sortedMapKeys(cfg.Workers)
	for _, name := range workerNames {
		worker := cfg.Workers[name]
		// Skip the default worker (it just references another worker)
		if name == DefaultWorkerName {
			continue
		}
		buf.WriteString(fmt.Sprintf("# [workers.%s]\n", name))
		if worker.Agent != "" {
			buf.WriteString(fmt.Sprintf("# agent = %q\n", worker.Agent))
		}
		if worker.Args != "" {
			buf.WriteString(fmt.Sprintf("# args = %q\n", worker.Args))
		}
		buf.WriteString("# model = \"\"  # Override model (e.g., \"opus\", \"sonnet\")\n")
		if worker.Description != "" {
			buf.WriteString(fmt.Sprintf("# description = %q\n", worker.Description))
		}
		buf.WriteString("\n")
	}

	// Custom worker example
	buf.WriteString("## Custom worker example (using custom agent)\n")
	buf.WriteString("# [workers.my-worker]\n")
	buf.WriteString("# agent = \"my-agent\"\n")
	buf.WriteString("# model = \"my-model-large\"\n")
	buf.WriteString("# args = \"--verbose\"\n")
	buf.WriteString("\n")

	// Managers section
	buf.WriteString("[managers.default]\n")
	buf.WriteString("## Manager configuration\n")
	buf.WriteString("## Managers are read-only agents for task orchestration.\n")
	buf.WriteString("## They can create and monitor tasks but delegate code to workers.\n")
	buf.WriteString("# agent = \"opencode\"   # Agent to use (builtin: claude, opencode)\n")
	buf.WriteString("# model = \"\"           # Model override (optional)\n")
	buf.WriteString("# system_args = \"\"     # System arguments (optional, defaults to builtin ManagerSystemArgs)\n")
	buf.WriteString("# args = \"\"            # Additional arguments (optional)\n")
	buf.WriteString("\n")

	// Complete section
	buf.WriteString("[complete]\n")
	buf.WriteString("## CI gate on completion\n")
	buf.WriteString("# command = \"mise run ci\"\n")
	buf.WriteString("\n\n")

	// Diff section
	buf.WriteString("[diff]\n")
	buf.WriteString("## Diff display settings\n")
	buf.WriteString("## - command: Shell command to display diff. Supports template variables:\n")
	buf.WriteString("##   - {{.BaseBranch}}: Task's base branch (e.g., \"main\")\n")
	buf.WriteString("##   - {{.Args}}: Additional arguments passed to the diff command\n")
	buf.WriteString("##   The command runs from the worktree directory.\n")
	buf.WriteString("## - tui_command: Command for TUI diff display (optional)\n")
	buf.WriteString("# command = \"git diff {{.BaseBranch}}...HEAD{{if .Args}} {{.Args}}{{end}}\"\n")
	buf.WriteString("# tui_command = \"git diff --color {{.BaseBranch}}...HEAD | less -R\"\n")
	buf.WriteString("\n")

	// Agents section
	buf.WriteString("## Custom Agent CLI configuration\n")
	buf.WriteString("## Agents define the core command execution pattern for AI tools.\n")
	buf.WriteString("## Built-in agents: claude, opencode\n")
	buf.WriteString("##\n")
	buf.WriteString("## Note: system_args is defined in Workers/Managers, not in Agents.\n")
	buf.WriteString("##       Agents only define command structure; Workers/Managers add role-specific args.\n")
	buf.WriteString("##\n")
	buf.WriteString("## Fields:\n")
	buf.WriteString("## - command: Base command to execute (e.g., \"claude\", \"opencode\")\n")
	buf.WriteString("## - command_template: How to assemble the full command\n")
	buf.WriteString("##   Available variables: {{.Command}}, {{.SystemArgs}}, {{.Args}}, {{.Prompt}}\n")
	buf.WriteString("## - default_model: Default model for this agent\n")
	buf.WriteString("## - description: Description of the agent's purpose\n")
	buf.WriteString("## - worktree_setup_script: Script to run after worktree creation (template-expanded)\n")
	buf.WriteString("##   Available variables: {{.Worktree}}, {{.TaskID}}, {{.Branch}}, etc.\n")
	buf.WriteString("## - exclude_patterns: Patterns to add to .git/info/exclude for this agent\n")
	buf.WriteString("\n")
	buf.WriteString("## Custom agent example\n")
	buf.WriteString("# [agents.my-agent]\n")
	buf.WriteString("# command = \"my-custom-agent\"\n")
	buf.WriteString("# command_template = \"{{.Command}} {{.SystemArgs}} {{.Args}} {{.Prompt}}\"\n")
	buf.WriteString("# default_model = \"my-model\"\n")
	buf.WriteString("# description = \"My custom AI agent\"\n")
	buf.WriteString("# worktree_setup_script = \"\"\"\n")
	buf.WriteString("# #!/bin/bash\n")
	buf.WriteString("# cd {{.Worktree}}\n")
	buf.WriteString("# echo \"Setting up worktree for task {{.TaskID}}\"\n")
	buf.WriteString("# \"\"\"\n")
	buf.WriteString("# exclude_patterns = [\".my-agent-cache/\"]\n")
	buf.WriteString("\n")

	// Log section
	buf.WriteString("## Log settings\n")
	buf.WriteString("# [log]\n")
	buf.WriteString(fmt.Sprintf("# level = %q  # debug, info, warn, error\n", cfg.Log.Level))

	return buf.String()
}

// sortedMapKeys returns the keys of a map sorted alphabetically.
func sortedMapKeys[V any](m map[string]V) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func formatPromptForTemplate(prompt string) string {
	if prompt == "" {
		return ""
	}

	trimmed := strings.TrimRight(prompt, "\n")
	lines := strings.Split(trimmed, "\n")

	var buf strings.Builder
	buf.WriteString(`"""`)
	for _, line := range lines {
		buf.WriteString("\n# ")
		buf.WriteString(line)
	}
	buf.WriteString("\n# \"\"\"")

	return buf.String()
}

// ResolveInheritance resolves worker inheritance by applying parent worker settings
// to child workers. It detects circular dependencies and returns an error if found.
// Workers without Inherit field are left unchanged.
// Only non-empty fields from the child override the parent fields.
func (c *Config) ResolveInheritance() error {
	// Track visited workers during traversal to detect circular dependencies
	visited := make(map[string]bool)
	resolving := make(map[string]bool)

	// Resolve each worker
	for name := range c.Workers {
		if err := c.resolveWorker(name, visited, resolving); err != nil {
			return err
		}
	}

	return nil
}

// resolveWorker recursively resolves inheritance for a single worker.
func (c *Config) resolveWorker(name string, visited, resolving map[string]bool) error {
	// Already resolved
	if visited[name] {
		return nil
	}

	// Circular dependency detected
	if resolving[name] {
		return ErrCircularInheritance
	}

	worker := c.Workers[name]

	// No inheritance, mark as resolved
	if worker.Inherit == "" {
		visited[name] = true
		return nil
	}

	// Mark as currently resolving
	resolving[name] = true

	// Check if parent exists
	_, exists := c.Workers[worker.Inherit]
	if !exists {
		delete(resolving, name)
		return ErrInheritParentNotFound
	}

	// Resolve parent first (recursive)
	if err := c.resolveWorker(worker.Inherit, visited, resolving); err != nil {
		delete(resolving, name)
		return err
	}

	// Get the resolved parent
	parent := c.Workers[worker.Inherit]

	// Apply inheritance: parent fields are used as defaults, child overrides if non-empty
	resolved := parent

	// Child overrides
	if worker.Agent != "" {
		resolved.Agent = worker.Agent
	}
	if worker.CommandTemplate != "" {
		resolved.CommandTemplate = worker.CommandTemplate
	}
	if worker.Command != "" {
		resolved.Command = worker.Command
	}
	if worker.SystemArgs != "" {
		resolved.SystemArgs = worker.SystemArgs
	}
	if worker.Args != "" {
		resolved.Args = worker.Args
	}
	if worker.SystemPrompt != "" {
		resolved.SystemPrompt = worker.SystemPrompt
	}
	if worker.Prompt != "" {
		resolved.Prompt = worker.Prompt
	}
	if worker.Model != "" {
		resolved.Model = worker.Model
	}
	if worker.Description != "" {
		resolved.Description = worker.Description
	}

	// Clear Inherit field after resolution
	resolved.Inherit = ""

	// Save resolved worker
	c.Workers[name] = resolved

	// Mark as resolved
	delete(resolving, name)
	visited[name] = true

	return nil
}
